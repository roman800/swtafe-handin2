/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class BaseClient {
  public async transformOptions(options: any): Promise<any> {
    const token = localStorage.getItem('jwt');
    const headerData = token
      ? {
          ...options.headers,
          Authorization: 'Bearer ' + token,
        }
      : {
          ...options.headers,
        };
    return Object.assign({}, options, {
      headers: headerData,
    });
  }
}

export class Client extends BaseClient {
  private http: {fetch(url: RequestInfo, init?: RequestInit): Promise<Response>};
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: {fetch(url: RequestInfo, init?: RequestInit): Promise<Response>}) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * Use this endpoint to add an exercise to an existing workout program.
   * @param programId programId for the program the exercise is added to.
   * @param body (optional) exercise
   * @return Success
   */
  program(programId: number, body: ExerciseDto | undefined): Promise<Exercise> {
    let url_ = this.baseUrl + '/api/Exercises/Program/{programId}';
    if (programId === undefined || programId === null) throw new Error("The parameter 'programId' must be defined.");
    url_ = url_.replace('{programId}', encodeURIComponent('' + programId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processProgram(_response);
      });
  }

  protected processProgram(response: Response): Promise<Exercise> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Exercise.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 201 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Exercise>(<any>null);
  }

  /**
   * Gets all exercises a trainer has in the system.
   * @return Success
   */
  exercisesAll(): Promise<Exercise[]> {
    let url_ = this.baseUrl + '/api/Exercises';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExercisesAll(_response);
      });
  }

  protected processExercisesAll(response: Response): Promise<Exercise[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Exercise.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Exercise[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exercisesPOST(body: Exercise | undefined): Promise<Exercise> {
    let url_ = this.baseUrl + '/api/Exercises';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExercisesPOST(_response);
      });
  }

  protected processExercisesPOST(response: Response): Promise<Exercise> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Exercise.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 201 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Exercise>(<any>null);
  }

  /**
   * @return Success
   */
  exercisesGET(id: number): Promise<Exercise> {
    let url_ = this.baseUrl + '/api/Exercises/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExercisesGET(_response);
      });
  }

  protected processExercisesGET(response: Response): Promise<Exercise> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Exercise.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Exercise>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exercisesPUT(id: number, body: Exercise | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Exercises/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExercisesPUT(_response);
      });
  }

  protected processExercisesPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  exercisesDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + '/api/Exercises/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'DELETE',
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExercisesDELETE(_response);
      });
  }

  protected processExercisesDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * You must login before you can use any other api call.
   * @param body (optional)
   * @return Success
   */
  login(body: Login | undefined): Promise<Token> {
    let url_ = this.baseUrl + '/api/Users/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processLogin(_response);
      });
  }

  protected processLogin(response: Response): Promise<Token> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Token.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Token>(<any>null);
  }

  /**
   * Use to change the password.
   * @param body (optional)
   * @return Success
   */
  password(body: NewPassword | undefined): Promise<Token> {
    let url_ = this.baseUrl + '/api/Users/Password';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processPassword(_response);
      });
  }

  protected processPassword(response: Response): Promise<Token> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Token.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Token>(<any>null);
  }

  /**
   * Get a let of all users
   * @return Success
   */
  usersAll(): Promise<User[]> {
    let url_ = this.baseUrl + '/api/Users';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUsersAll(_response);
      });
  }

  protected processUsersAll(response: Response): Promise<User[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(User.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User[]>(<any>null);
  }

  /**
     * Valid accountTypes are: Client and PersonalTrainer".
    The userId is set by the backend.
    The personalTrainerId is only used for clients.
    Valid accountTypes are PersonalTrainer and Client.
     * @param body (optional) 
     * @return Success
     */
  usersPOST(body: User | undefined): Promise<User> {
    let url_ = this.baseUrl + '/api/Users';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUsersPOST(_response);
      });
  }

  protected processUsersPOST(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 201 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Gets the list of clients for a personal trainer.
   * @return Success
   */
  clients(): Promise<User[]> {
    let url_ = this.baseUrl + '/api/Users/Clients';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processClients(_response);
      });
  }

  protected processClients(response: Response): Promise<User[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(User.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User[]>(<any>null);
  }

  /**
   * Returns the personal trainer for the logged in user.
   * @return Success
   */
  trainerUser(): Promise<User> {
    let url_ = this.baseUrl + '/api/Users/Trainer';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processTrainerUser(_response);
      });
  }

  protected processTrainerUser(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * @return Success
   */
  usersGET(id: number): Promise<User> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUsersGET(_response);
      });
  }

  protected processUsersGET(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  usersPUT(id: number, body: User | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUsersPUT(_response);
      });
  }

  protected processUsersPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  usersDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'DELETE',
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUsersDELETE(_response);
      });
  }

  protected processUsersDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  trainerWorkOut(): Promise<WorkoutProgram[]> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms/trainer';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processTrainerWorkOut(_response);
      });
  }

  protected processTrainerWorkOut(response: Response): Promise<WorkoutProgram[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(WorkoutProgram.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<WorkoutProgram[]>(<any>null);
  }

  /**
   * @return Success
   */
  client(id: number): Promise<WorkoutProgram[]> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms/client/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processClient(_response);
      });
  }

  protected processClient(response: Response): Promise<WorkoutProgram[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(WorkoutProgram.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<WorkoutProgram[]>(<any>null);
  }

  /**
   * @return Success
   */
  workoutProgramsAll(): Promise<WorkoutProgram[]> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processWorkoutProgramsAll(_response);
      });
  }

  protected processWorkoutProgramsAll(response: Response): Promise<WorkoutProgram[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(WorkoutProgram.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<WorkoutProgram[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  workoutProgramsPOST(body: WorkoutProgram | undefined): Promise<WorkoutProgram> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processWorkoutProgramsPOST(_response);
      });
  }

  protected processWorkoutProgramsPOST(response: Response): Promise<WorkoutProgram> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = WorkoutProgram.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 201 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<WorkoutProgram>(<any>null);
  }

  /**
   * @return Success
   */
  workoutProgramsGET(id: number): Promise<WorkoutProgram> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processWorkoutProgramsGET(_response);
      });
  }

  protected processWorkoutProgramsGET(response: Response): Promise<WorkoutProgram> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = WorkoutProgram.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<WorkoutProgram>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  workoutProgramsPUT(id: number, body: WorkoutProgram | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processWorkoutProgramsPUT(_response);
      });
  }

  protected processWorkoutProgramsPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  workoutProgramsDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + '/api/WorkoutPrograms/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'DELETE',
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processWorkoutProgramsDELETE(_response);
      });
  }

  protected processWorkoutProgramsDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ExerciseDto implements IExerciseDto {
  name?: string | undefined;
  description?: string | undefined;
  sets?: number | undefined;
  repetitions?: number | undefined;
  time?: string | undefined;

  constructor(data?: IExerciseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.sets = _data['sets'];
      this.repetitions = _data['repetitions'];
      this.time = _data['time'];
    }
  }

  static fromJS(data: any): ExerciseDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExerciseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['sets'] = this.sets;
    data['repetitions'] = this.repetitions;
    data['time'] = this.time;
    return data;
  }
}

export interface IExerciseDto {
  name?: string | undefined;
  description?: string | undefined;
  sets?: number | undefined;
  repetitions?: number | undefined;
  time?: string | undefined;
}

export class Exercise implements IExercise {
  /** Primary key */
  exerciseId?: number;
  name?: string | undefined;
  description?: string | undefined;
  sets?: number | undefined;
  repetitions?: number | undefined;
  time?: string | undefined;
  /** FK */
  workoutProgramId?: number | undefined;
  /** FK to personal trainer */
  personalTrainerId?: number | undefined;

  constructor(data?: IExercise) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exerciseId = _data['exerciseId'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.sets = _data['sets'];
      this.repetitions = _data['repetitions'];
      this.time = _data['time'];
      this.workoutProgramId = _data['workoutProgramId'];
      this.personalTrainerId = _data['personalTrainerId'];
    }
  }

  static fromJS(data: any): Exercise {
    data = typeof data === 'object' ? data : {};
    let result = new Exercise();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['exerciseId'] = this.exerciseId;
    data['name'] = this.name;
    data['description'] = this.description;
    data['sets'] = this.sets;
    data['repetitions'] = this.repetitions;
    data['time'] = this.time;
    data['workoutProgramId'] = this.workoutProgramId;
    data['personalTrainerId'] = this.personalTrainerId;
    return data;
  }
}

export interface IExercise {
  /** Primary key */
  exerciseId?: number;
  name?: string | undefined;
  description?: string | undefined;
  sets?: number | undefined;
  repetitions?: number | undefined;
  time?: string | undefined;
  /** FK */
  workoutProgramId?: number | undefined;
  /** FK to personal trainer */
  personalTrainerId?: number | undefined;
}

export class Login implements ILogin {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILogin) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): Login {
    data = typeof data === 'object' ? data : {};
    let result = new Login();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface ILogin {
  email?: string | undefined;
  password?: string | undefined;
}

export class Token implements IToken {
  jwt?: string | undefined;

  constructor(data?: IToken) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jwt = _data['jwt'];
    }
  }

  static fromJS(data: any): Token {
    data = typeof data === 'object' ? data : {};
    let result = new Token();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['jwt'] = this.jwt;
    return data;
  }
}

export interface IToken {
  jwt?: string | undefined;
}

export class NewPassword implements INewPassword {
  email?: string | undefined;
  password?: string | undefined;
  oldPassword?: string | undefined;

  constructor(data?: INewPassword) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
      this.oldPassword = _data['oldPassword'];
    }
  }

  static fromJS(data: any): NewPassword {
    data = typeof data === 'object' ? data : {};
    let result = new NewPassword();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    data['oldPassword'] = this.oldPassword;
    return data;
  }
}

export interface INewPassword {
  email?: string | undefined;
  password?: string | undefined;
  oldPassword?: string | undefined;
}

export class User implements IUser {
  userId?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;
  personalTrainerId?: number | undefined;
  accountType?: string | undefined;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.email = _data['email'];
      this.password = _data['password'];
      this.personalTrainerId = _data['personalTrainerId'];
      this.accountType = _data['accountType'];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    data['password'] = this.password;
    data['personalTrainerId'] = this.personalTrainerId;
    data['accountType'] = this.accountType;
    return data;
  }
}

export interface IUser {
  userId?: number;
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  password?: string | undefined;
  personalTrainerId?: number | undefined;
  accountType?: string | undefined;
}

export class WorkoutProgram implements IWorkoutProgram {
  workoutProgramId?: number;
  name?: string | undefined;
  description?: string | undefined;
  exercises?: Exercise[] | undefined;
  personalTrainerId?: number;
  clientId?: number | undefined;

  constructor(data?: IWorkoutProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.workoutProgramId = _data['workoutProgramId'];
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['exercises'])) {
        this.exercises = [] as any;
        for (let item of _data['exercises']) this.exercises!.push(Exercise.fromJS(item));
      }
      this.personalTrainerId = _data['personalTrainerId'];
      this.clientId = _data['clientId'];
    }
  }

  static fromJS(data: any): WorkoutProgram {
    data = typeof data === 'object' ? data : {};
    let result = new WorkoutProgram();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['workoutProgramId'] = this.workoutProgramId;
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.exercises)) {
      data['exercises'] = [];
      for (let item of this.exercises) data['exercises'].push(item.toJSON());
    }
    data['personalTrainerId'] = this.personalTrainerId;
    data['clientId'] = this.clientId;
    return data;
  }
}

export interface IWorkoutProgram {
  workoutProgramId?: number;
  name?: string | undefined;
  description?: string | undefined;
  exercises?: Exercise[] | undefined;
  personalTrainerId?: number;
  clientId?: number | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: {[key: string]: any};
  result: any;

  constructor(message: string, status: number, response: string, headers: {[key: string]: any}, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: {[key: string]: any},
  result?: any,
): any {
  throw new ApiException(message, status, response, headers, result);
}
